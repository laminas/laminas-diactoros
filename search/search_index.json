{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-diactoros üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º –ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\" üá∫üá∏ To Citizens of Russia We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" Diactoros (pronunciation: /d…™ åkt…ír…ís/ ): an epithet for Hermes, meaning literally, \"the messenger.\" This package supercedes and replaces phly/http . laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces and PSR-17 HTTP message factory interfaces . File issues at https://github.com/laminas/laminas-diactoros/issues Issue patches to https://github.com/laminas/laminas-diactoros/pulls Documentation Documentation is available at: https://docs.laminas.dev/laminas-diactoros/ Source files for documentation are in the docs/ tree . Contributing and Support If you need support with the project, read the support documentation . If you wish to contribute to the project, read the contributing guidelines as well as the Code of Conduct . For reporting security issues, please review our security policy .","title":"Home"},{"location":"#laminas-diactoros","text":"","title":"laminas-diactoros"},{"location":"#_1","text":"–ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\"","title":"üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º"},{"location":"#to-citizens-of-russia","text":"We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" Diactoros (pronunciation: /d…™ åkt…ír…ís/ ): an epithet for Hermes, meaning literally, \"the messenger.\" This package supercedes and replaces phly/http . laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces and PSR-17 HTTP message factory interfaces . File issues at https://github.com/laminas/laminas-diactoros/issues Issue patches to https://github.com/laminas/laminas-diactoros/pulls","title":"üá∫üá∏ To Citizens of Russia"},{"location":"#documentation","text":"Documentation is available at: https://docs.laminas.dev/laminas-diactoros/ Source files for documentation are in the docs/ tree .","title":"Documentation"},{"location":"#contributing-and-support","text":"If you need support with the project, read the support documentation . If you wish to contribute to the project, read the contributing guidelines as well as the Code of Conduct . For reporting security issues, please review our security policy .","title":"Contributing and Support"},{"location":"v1/api/","text":"API Request Message Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. ServerRequest Message For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. HtmlResponse and JsonResponse Available since version 1.1.0 The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Laminas\\Diactoros\\Response\\HtmlResponse and Laminas\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' =&gt; [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' =&gt; [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); ServerRequestFactory Helper Functions Available since version 1.8.0 In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Laminas\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Laminas\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Laminas\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Laminas\\Diactoros\\marshalMethodFromSapi(array $server) : string Laminas\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri Laminas\\Diactoros\\marshalHeadersFromSapi(array $server) : array Laminas\\Diactoros\\parseCookieHeader(string $header) : array Laminas\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Laminas\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Stream Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface . Server Deprecated The class Laminas\\Diactoros\\Server is deprecated as of the 1.8.0 release. We recommend using the class Laminas\\HttpHandlerRunner\\RequestHandlerRunner via the package laminas/laminas-httphandlerrunner instead. Laminas\\Diactoros\\Server represents a server capable of executing a callback. It has four methods: class Server { public function __construct( callable $callback, Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response ); public static function createServer( callable $callback, array $server, // usually $_SERVER array $query, // usually $_GET array $body, // usually $_POST array $cookies, // usually $_COOKIE array $files // usually $_FILES ); public static function createServerFromRequest( callable $callback, Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response = null ); public function setEmitter(Response\\EmitterInterface $emitter); public function listen(callable $finalHandler = null); } You can create an instance of the Server using any of the constructor, createServer() , or createServerFromRequest() methods. If you wish to use the default request and response implementations, createServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES) is the recommended option, as this method will also marshal the ServerRequest object based on the PHP request environment. If you wish to use your own implementations, pass them to the constructor or createServerFromRequest() method (the latter will create a default Response instance if you omit it). listen() executes the callback. If a $finalHandler is provided, it will be passed as the third argument to the $callback registered with the server.","title":"API"},{"location":"v1/api/#api","text":"","title":"API"},{"location":"v1/api/#request-message","text":"Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Request Message"},{"location":"v1/api/#serverrequest-message","text":"For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v1/api/#response-message","text":"Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Response Message"},{"location":"v1/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v1/api/#uri","text":"Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"URI"},{"location":"v1/api/#stream","text":"Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v1/api/#uploadedfile","text":"Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v1/api/#server","text":"","title":"Server"},{"location":"v1/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new TextResponse($text, 200, ['Content-Type' =&gt; ['text/csv']]); HTML Responses Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' =&gt; ['application/xhtml+xml']]); Headers must be in the same format as you would provide to the Response constructor . XML Responses Available since version 1.7.0 Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new XmlResponse($xml, 200, [ 'Content-Type' =&gt; ['application/hal+xml']]); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new JsonResponse($data, 200, [ 'Content-Type' =&gt; ['application/hal+json']]); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = ( new EmptyResponse(201) )-&gt;withHeader('Location', $url); Redirects Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v1/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v1/custom-responses/#text-responses","text":"Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new TextResponse($text, 200, ['Content-Type' =&gt; ['text/csv']]);","title":"Text Responses"},{"location":"v1/custom-responses/#html-responses","text":"Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' =&gt; ['application/xhtml+xml']]); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v1/custom-responses/#xml-responses","text":"Available since version 1.7.0 Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new XmlResponse($xml, 200, [ 'Content-Type' =&gt; ['application/hal+xml']]); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v1/custom-responses/#json-responses","text":"Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new JsonResponse($data, 200, [ 'Content-Type' =&gt; ['application/hal+json']]); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v1/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = ( new EmptyResponse(201) )-&gt;withHeader('Location', $url);","title":"Empty Responses"},{"location":"v1/custom-responses/#redirects","text":"Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login'));","title":"Redirects"},{"location":"v1/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v1/emitting-responses/","text":"Emitting Responses Introduction Deprecated Emitters are deprecated from Diactoros starting with version 1.8.0. The functionality is now available for any PSR-7 implementation via the package laminas/laminas-httphandlerrunner . We suggest using that functionality instead. If you are using a non-SAPI PHP implementation and wish to use the Server class, or if you do not want to use the Server implementation but want to emit a response, this package provides an interface, Laminas\\Diactoros\\Response\\EmitterInterface , defining a method emit() for emitting the response. Diactoros provides two implementations currently, both for working with traditional Server API (SAPI) implementations: Laminas\\Diactoros\\Response\\SapiEmitter and Laminas\\Diactoros\\Response\\SapiStreamEmitter . Each uses the native header() PHP function to emit headers, and echo() to emit the response body. If you are using a non-SAPI implementation, you will need to create your own EmitterInterface implementation. For example, the SapiEmitter implementation of the EmitterInterface can be used thus: $response = new Laminas\\Diactoros\\Response(); $response-&gt;getBody()-&gt;write(\"some content\\n\"); $emitter = new Laminas\\Diactoros\\Response\\SapiEmitter(); $emitter-&gt;emit($response); Emitting Ranges of streamed Files The SapiStreamEmitter is useful when you want to emit a Content-Range . As an example, to stream a range of bytes from a file to a client, the client can pass the following header: Range: bytes=1024-2047 Your application would then populate the response with a Content-Range header: $range = $request-&gt;getHeaderLine('range'); $range = str_replace('=', ' ', $range); $body = new Stream($pathToFile); $size = $body-&gt;getSize(); $range .= '/' . $size; $response = new Response($body); $response = $response-&gt;withHeader('Content-Range', $range); (Note: you will likely want to ensure the range specified falls within the content size of the streamed body!) The SapiStreamEmitter detects the Content-Range header and emits only the bytes specified. $emitter = new SapiStreamEmitter(); $emitter-&gt;emit($response); The SapiStreamEmitter may be used in place of the SapiEmitter , even when not sending files. However, unlike the SapiEmitter , it will emit a chunk of content at a time instead of the full content at once, which could lead to performance overhead. The default chunk size is 8192 bytes.","title":"Emitting Responses"},{"location":"v1/emitting-responses/#emitting-responses","text":"","title":"Emitting Responses"},{"location":"v1/emitting-responses/#introduction","text":"","title":"Introduction"},{"location":"v1/emitting-responses/#emitting-ranges-of-streamed-files","text":"The SapiStreamEmitter is useful when you want to emit a Content-Range . As an example, to stream a range of bytes from a file to a client, the client can pass the following header: Range: bytes=1024-2047 Your application would then populate the response with a Content-Range header: $range = $request-&gt;getHeaderLine('range'); $range = str_replace('=', ' ', $range); $body = new Stream($pathToFile); $size = $body-&gt;getSize(); $range .= '/' . $size; $response = new Response($body); $response = $response-&gt;withHeader('Content-Range', $range); (Note: you will likely want to ensure the range specified falls within the content size of the streamed body!) The SapiStreamEmitter detects the Content-Range header and emits only the bytes specified. $emitter = new SapiStreamEmitter(); $emitter-&gt;emit($response); The SapiStreamEmitter may be used in place of the SapiEmitter , even when not sending files. However, unlike the SapiEmitter , it will emit a chunk of content at a time instead of the full content at once, which could lead to performance overhead. The default chunk size is 8192 bytes.","title":"Emitting Ranges of streamed Files"},{"location":"v1/install/","text":"Installation Install this library using composer: $ composer require \"laminas/laminas-diactoros:^1.8.6\" laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v1/install/#installation","text":"Install this library using composer: $ composer require \"laminas/laminas-diactoros:^1.8.6\" laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v1/overview/","text":"Overview laminas-diactoros is a PHP package containing implementations of the accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to node's http.Server . This package exists: to provide an implementation of PSR-7 HTTP message interfaces with relation to server-side applications. to provide a common methodology for marshaling a request from the server environment.","title":"Overview"},{"location":"v1/overview/#overview","text":"laminas-diactoros is a PHP package containing implementations of the accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to node's http.Server . This package exists: to provide an implementation of PSR-7 HTTP message interfaces with relation to server-side applications. to provide a common methodology for marshaling a request from the server environment.","title":"Overview"},{"location":"v1/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this-&gt;logger-&gt;debug('Request/Response', [ 'request' =&gt; \\Laminas\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' =&gt; \\Laminas\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v1/serialization/#serialization","text":"","title":"Serialization"},{"location":"v1/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v1/serialization/#array","text":"This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v1/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Laminas\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Laminas\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Laminas\\Diactoros\\Response(); // Write to the response body: $response-&gt;getBody()-&gt;write(\"some content\\n\"); // Multiple calls to write() append: $response-&gt;getBody()-&gt;write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response -&gt;withHeader('Content-Type', 'text/plain') -&gt;withAddedHeader('X-Show-Something', 'something'); \"Serving\" an Application Deprecated The class Laminas\\Diactoros\\Server is deprecated as of the 1.8.0 release. We recommend using the class Laminas\\HttpHandlerRunner\\RequestHandlerRunner via the package laminas/laminas-httphandlerrunner instead. Laminas\\Diactoros\\Server mimics a portion of the API of node's http.Server class. It invokes a callback, passing it an ServerRequest , an Response , and optionally a callback to use for incomplete/unhandled requests. You can create a server in one of three ways: // Direct instantiation, with a callback handler, request, and response $server = new Laminas\\Diactoros\\Server( function ($request, $response, $done) { $response-&gt;getBody()-&gt;write(\"Hello world!\"); }, $request, $response ); // Using the createServer factory, providing it with the various superglobals: $server = Laminas\\Diactoros\\Server::createServer( function ($request, $response, $done) { $response-&gt;getBody()-&gt;write(\"Hello world!\"); }, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); // Using the createServerFromRequest factory, and providing it a request: $server = Laminas\\Diactoros\\Server::createServerFromRequest( function ($request, $response, $done) { $response-&gt;getBody()-&gt;write(\"Hello world!\"); }, $request ); Server callbacks can expect up to three arguments, in the following order: $request - the request object $response - the response object $done - an optional callback to call when complete Once you have your server instance, you must instruct it to listen: $server-&gt;listen(); At this time, you can optionally provide a callback to listen() ; this will be passed to the handler as the third argument ( $done ): $server-&gt;listen(function ($request, $response, $error = null) { if (! $error) { return; } // do something with the error... }); Typically, the listen callback will be an error handler, and can expect to receive the request, response, and error as its arguments (though the error may be null).","title":"Usage"},{"location":"v1/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v1/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v1/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"},{"location":"v2/api/","text":"API Request Message Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. ServerRequest Message For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. HtmlResponse and JsonResponse The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Laminas\\Diactoros\\Response\\HtmlResponse and Laminas\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' =&gt; [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' =&gt; [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); ServerRequestFactory Helper Functions In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Laminas\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Laminas\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Laminas\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Laminas\\Diactoros\\marshalMethodFromSapi(array $server) : string Laminas\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri Laminas\\Diactoros\\marshalHeadersFromSapi(array $server) : array Laminas\\Diactoros\\parseCookieHeader(string $header) : array Laminas\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Laminas\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Stream Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be one of: A stream identifier; e.g., php://input , a filename, etc. A PHP stream resource; or A GD resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"API"},{"location":"v2/api/#api","text":"","title":"API"},{"location":"v2/api/#request-message","text":"Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Request Message"},{"location":"v2/api/#serverrequest-message","text":"For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v2/api/#response-message","text":"Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Response Message"},{"location":"v2/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v2/api/#uri","text":"Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"URI"},{"location":"v2/api/#stream","text":"Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be one of: A stream identifier; e.g., php://input , a filename, etc. A PHP stream resource; or A GD resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v2/api/#uploadedfile","text":"Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v2/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Laminas\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Laminas\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Laminas\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' =&gt; ['text/csv']] ); HTML Responses Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Laminas\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' =&gt; ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor . XML Responses Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Laminas\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' =&gt; ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Laminas\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' =&gt; ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Laminas\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))-&gt;withHeader('Location', $url); Redirects Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Laminas\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Laminas\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Laminas\\Diactoros\\Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v2/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Laminas\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v2/custom-responses/#text-responses","text":"Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Laminas\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Laminas\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' =&gt; ['text/csv']] );","title":"Text Responses"},{"location":"v2/custom-responses/#html-responses","text":"Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Laminas\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' =&gt; ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v2/custom-responses/#xml-responses","text":"Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Laminas\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' =&gt; ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v2/custom-responses/#json-responses","text":"Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Laminas\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' =&gt; ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v2/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Laminas\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))-&gt;withHeader('Location', $url);","title":"Empty Responses"},{"location":"v2/custom-responses/#redirects","text":"Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Laminas\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login'));","title":"Redirects"},{"location":"v2/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Laminas\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Laminas\\Diactoros\\Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v2/factories/","text":"Factories PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Laminas\\Diactoros\\RequestFactory Laminas\\Diactoros\\ResponseFactory Laminas\\Diactoros\\ServerRequestFactory Laminas\\Diactoros\\StreamFactory Laminas\\Diactoros\\UploadedFileFactory Laminas\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints. Autoregistration of factories Since 2.3.0 When installing Diactoros in a Laminas or Mezzio application, or any application using the laminas-component-installer plugin , you will now be prompted to install its ConfigProvider and/or Module . When you do, it registers the Diactoros factory implementations under the PSR-17 interface names, allowing you to compose instances of the interface in your application classes..","title":"Factories"},{"location":"v2/factories/#factories","text":"PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Laminas\\Diactoros\\RequestFactory Laminas\\Diactoros\\ResponseFactory Laminas\\Diactoros\\ServerRequestFactory Laminas\\Diactoros\\StreamFactory Laminas\\Diactoros\\UploadedFileFactory Laminas\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints.","title":"Factories"},{"location":"v2/factories/#autoregistration-of-factories","text":"Since 2.3.0 When installing Diactoros in a Laminas or Mezzio application, or any application using the laminas-component-installer plugin , you will now be prompted to install its ConfigProvider and/or Module . When you do, it registers the Diactoros factory implementations under the PSR-17 interface names, allowing you to compose instances of the interface in your application classes..","title":"Autoregistration of factories"},{"location":"v2/install/","text":"Installation Install this library using composer: $ composer require laminas/laminas-diactoros laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v2/install/#installation","text":"Install this library using composer: $ composer require laminas/laminas-diactoros laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v2/migration/","text":"Migration to Version 2 If you are only using the PSR-7 implementations (e.g., Request , Response , ServerRequest , etc.), migrating to v2 can be done by updating your laminas/laminas-diactoros constraint in your composer.json . You have two options for doing so: Adopt the v2 release specifically: $ composer require \"laminas/laminas-diactoros:^2.0\" Update your constraint to allow either version: Edit the constraint in your composer.json to read: \"laminas/laminas-diactoros\": \"^1.8.6 || ^2.0\" Update your dependencies: $ composer update The first approach may fail if libraries you depend on specifically require a version 1 release. The second approach may leave you on a version 1 release in situations where other libraries you depend on require version 1. In all cases, if you are only using the PSR-7 implementations and/or the ServerRequestFactory::fromGlobals() functionality, upgrading to version 2 will pose no backwards compatibility issues. Changed Laminas\\Diactoros\\RequestTrait now raises an InvalidArgumentException in withMethod() for invalid HTTP method values. Laminas\\Diactoros\\Serializer\\Request::toString() no longer raises an UnexpectedValueException due to an unexpected HTTP method; this is due to the fact that the HTTP method value can no longer be set to an invalid value. Removed Several features were removed for version 2. These include removal of the Emitter functionality, the Server implementation, and a number of methods on the ServerRequestFactory . Emitters Laminas\\Diactoros\\Response\\EmitterInterface and all emitter implementations were removed from laminas-diactoros. They are now available in the laminas/laminas-httphandlerrunner package . In most cases, these can be replaced by changing the namespace of imported classes from Laminas\\Diactoros\\Response to Laminas\\HttpHandlerRunner\\Emitter . Server The Laminas\\Diactoros\\Server class has been removed. We recommend using the RequestHandlerRunner class from laminas/laminas-httphandlerrunner to provide these capabilities instead. Usage is similar, but the RequestHandlerRunner provides better error handling, and integration with emitters. ServerRequestFactory Methods A number of public static methods have been removed from ServerRequestFactory . The following table details the methods removed, and replacements you may use if you still require the functionality. Method Removed Replacement functionality normalizeServer() Laminas\\Diactoros\\normalizeServer() marshalHeaders() Laminas\\Diactoros\\marshalHeadersFromSapi() marshalUriFromServer() Laminas\\Diactoros\\marshalUriFromSapi() marshalRequestUri() Uri::getPath() from the Uri instance returned by marshalUriFromSapi() marshalHostAndPortFromHeaders() Uri::getHost() and Uri::getPort() from the Uri instances returned by marshalUriFromSapi() stripQueryString() explode(\"?\", $path, 2)[0] normalizeFiles() Laminas\\Diactoros\\normalizeUploadedFiles()","title":"Migration to Version 2"},{"location":"v2/migration/#migration-to-version-2","text":"If you are only using the PSR-7 implementations (e.g., Request , Response , ServerRequest , etc.), migrating to v2 can be done by updating your laminas/laminas-diactoros constraint in your composer.json . You have two options for doing so: Adopt the v2 release specifically: $ composer require \"laminas/laminas-diactoros:^2.0\" Update your constraint to allow either version: Edit the constraint in your composer.json to read: \"laminas/laminas-diactoros\": \"^1.8.6 || ^2.0\" Update your dependencies: $ composer update The first approach may fail if libraries you depend on specifically require a version 1 release. The second approach may leave you on a version 1 release in situations where other libraries you depend on require version 1. In all cases, if you are only using the PSR-7 implementations and/or the ServerRequestFactory::fromGlobals() functionality, upgrading to version 2 will pose no backwards compatibility issues.","title":"Migration to Version 2"},{"location":"v2/migration/#changed","text":"Laminas\\Diactoros\\RequestTrait now raises an InvalidArgumentException in withMethod() for invalid HTTP method values. Laminas\\Diactoros\\Serializer\\Request::toString() no longer raises an UnexpectedValueException due to an unexpected HTTP method; this is due to the fact that the HTTP method value can no longer be set to an invalid value.","title":"Changed"},{"location":"v2/migration/#removed","text":"Several features were removed for version 2. These include removal of the Emitter functionality, the Server implementation, and a number of methods on the ServerRequestFactory .","title":"Removed"},{"location":"v2/overview/","text":"Overview laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v2/overview/#overview","text":"laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v2/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this-&gt;logger-&gt;debug('Request/Response', [ 'request' =&gt; \\Laminas\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' =&gt; \\Laminas\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v2/serialization/#serialization","text":"","title":"Serialization"},{"location":"v2/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v2/serialization/#array","text":"This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v2/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Laminas\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Laminas\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Strict Content- header matching Available since version 2.6.0 By default, Diactoros will resolve any $_SERVER keys matching the prefix CONTENT_ as HTTP headers. However, the proper behavior is to only match CONTENT_TYPE , CONTENT_LENGTH , and CONTENT_MD5 , mapping them to Content-Type , Content-Length , and Content-MD5 headers, respectively. Since changing the existing behavior may break some applications, we will not make the functionality more restrictive before version 3.0.0. If you are running into issues whereby you have ENV variables that are being munged into request headers, you can define the following ENV variable in your application to enable the more strict behavior: LAMINAS_DIACTOROS_STRICT_CONTENT_HEADER_LOOKUP As an example, you could define it in your application's .env file if you are using vlucas/phpdotenv : LAMINAS_DIACTOROS_STRICT_CONTENT_HEADER_LOOKUP=true Alternately, you could define it as a php-fpm or Apache environment variable. Once this ENV variable is present, the logic for identifying Content-* headers will only look at the CONTENT_TYPE , CONTENT_LENGTH , and CONTENT_MD5 variables in $_SERVER , and skip over any others. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Laminas\\Diactoros\\Response(); // Write to the response body: $response-&gt;getBody()-&gt;write(\"some content\\n\"); // Multiple calls to write() append: $response-&gt;getBody()-&gt;write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response -&gt;withHeader('Content-Type', 'text/plain') -&gt;withAddedHeader('X-Show-Something', 'something');","title":"Usage"},{"location":"v2/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v2/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v2/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"}]}